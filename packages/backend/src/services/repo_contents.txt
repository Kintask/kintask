===== ./filecoinService.ts =====
// ./packages/backend/src/services/filecoinService.ts
import axios, { AxiosError } from 'axios';
import config from '../config';
import { truncateText } from '../utils';

const IPFS_GATEWAY = config.ipfsGatewayUrl || 'https://w3s.link/ipfs/';
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 800;
const REQUEST_TIMEOUT = 25000;

console.log(`[Filecoin Service] Using IPFS Gateway: ${IPFS_GATEWAY}`);
interface CacheEntry<T> { data: T; timestamp: number; }
const cache = new Map<string, CacheEntry<any>>();
const CACHE_TTL_MS = 10 * 60 * 1000;
function setCache<T>(key: string, data: T) { if (!key) return; cache.set(key, { data, timestamp: Date.now() }); }
function getCache<T>(key: string): T | null { if (!key) return null; const entry = cache.get(key); if (entry && (Date.now() - entry.timestamp < CACHE_TTL_MS)) { return entry.data as T; } cache.delete(key); return null; }

async function fetchWithRetry(url: string, cacheKey: string): Promise<string | null> {
    const cachedData = getCache<string>(cacheKey);
    if (cachedData) { console.log(`[Filecoin Service DEBUG] Cache HIT for ${cacheKey.substring(0,10)}...`); return cachedData; }
    console.log(`[Filecoin Service] Fetching: ${url.substring(0, 60)}... (Key: ${cacheKey.substring(0,10)}...)`);
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            const response = await axios.get<string>(url, { timeout: REQUEST_TIMEOUT, responseType: 'text', headers: { 'Accept': 'text/plain, */*' } });
            if (response.status === 200 && typeof response.data === 'string') {
                setCache(cacheKey, response.data); console.log(`[Filecoin Service DEBUG] Fetched content OK (len: ${response.data.length})`); console.log(`[Filecoin Service DEBUG] Content sample: ${truncateText(response.data, 300)}`); return response.data;
            } else { console.warn(`[Filecoin Service] Fetch attempt ${attempt} status: ${response.status}, type: ${typeof response.data}`); }
        } catch (error: any) { const axiosError = error as AxiosError; const conciseError = axiosError.message.split('\n')[0]; console.warn(`[Filecoin Service] Fetch Error ${attempt}/${MAX_RETRIES}: ${conciseError}`); if (axiosError.response?.status === 404) { console.error(`[Filecoin Service] CID ${cacheKey.substring(0,10)}... 404 Not Found.`); return null; } if (attempt === MAX_RETRIES) { console.error(`[Filecoin Service] Final fetch attempt failed: ${cacheKey.substring(0,10)}...`); return null; } const delay = RETRY_DELAY_MS * Math.pow(2, attempt - 1); await new Promise(resolve => setTimeout(resolve, delay)); }
    }
    console.error(`[Filecoin Service] Fetch failed unexpectedly: ${cacheKey.substring(0,10)}...`); return null;
}

export async function fetchKnowledgeSourceContent(): Promise<string | null> {
    const sourceCid = config.knowledgeBaseIndexCid;
    if (!sourceCid) { console.error('[Filecoin Service] Error: KB_INDEX_CID not configured.'); return null; }
    if (typeof sourceCid !== 'string' || sourceCid.trim() === '' || (!sourceCid.startsWith('bafy') && !sourceCid.startsWith('bafk') && !sourceCid.startsWith('Qm'))) { console.error(`[Filecoin Service] Invalid KB_INDEX_CID format: ${sourceCid}`); return null; }
    const url = `${IPFS_GATEWAY}${sourceCid}`; console.log(`[Filecoin Service] Fetching Knowledge Source (CID: ${sourceCid.substring(0,10)}...)`);
    return await fetchWithRetry(url, sourceCid);
}

export function clearFilecoinCache() { console.log("[Filecoin Service] Clearing cache."); cache.clear(); }===== ./generatorService.ts =====
// services/generatorService.ts
import axios, { AxiosError } from 'axios';
import config from '../config';
// --- REMOVED Recall import ---
// import { logRecallEvent } from './recallService';
import { truncateText } from '../utils';

const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";
const API_KEY = config.openRouterApiKey;
const MODEL_IDENTIFIER = "mistralai/mistral-7b-instruct:free";

// Rate Limiting Configuration
const RATE_LIMIT_WINDOW_MS = 60 * 1000; // 60 seconds window
const MAX_REQUESTS_PER_WINDOW = 10; // Allow 10 requests per minute
const RATE_LIMIT_RETRY_DELAY_MS = 15000; // Wait 15 seconds if limit is hit
let requestTimestamps: number[] = [];

const MAX_TOKENS_CLAIM = 50;
const TEMPERATURE_CLAIM = 0.3;
const MAX_TOKENS_VERIFY = 30;
const TEMPERATURE_VERIFY = 0.1;

let isGeneratorInitialized = false;
function initializeGenerator() {
    if (isGeneratorInitialized) return;
    console.log("[Generator Service] Initializing OpenRouter configuration...");
    if (!API_KEY) { console.error("[Generator Service] FATAL ERROR: OPENROUTER_API_KEY variable is missing."); isGeneratorInitialized = false; return; }
    console.log(`[Generator Service] Using API Key starting with: ${API_KEY.substring(0, 10)}...`);
    console.log(`[Generator Service] Configured model: ${MODEL_IDENTIFIER}`);
    isGeneratorInitialized = true;
}

// Rate Limiter Function
async function waitForRateLimit(context?: string, agentId?: string): Promise<void> {
    const now = Date.now();
    requestTimestamps = requestTimestamps.filter(ts => now - ts < RATE_LIMIT_WINDOW_MS);
    const identifier = agentId ? `Agent ${agentId}` : `ClaimGen`;
    const logPrefix = `[Rate Limiter - ${identifier} | Context: ${context?.substring(0, 10)}...]`;
    while (requestTimestamps.length >= MAX_REQUESTS_PER_WINDOW) {
        console.warn(`${logPrefix} Rate limit hit. Waiting ${RATE_LIMIT_RETRY_DELAY_MS / 1000}s...`);
        await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_RETRY_DELAY_MS));
        const currentTime = Date.now();
        requestTimestamps = requestTimestamps.filter(ts => currentTime - ts < RATE_LIMIT_WINDOW_MS);
    }
    requestTimestamps.push(now);
}

// generateClaim function
export async function generateClaim(question: string, requestContext?: string): Promise<string> {
    if (!isGeneratorInitialized) initializeGenerator();
    if (!API_KEY || !isGeneratorInitialized) { console.error("[Generator Service] Cannot generate claim: Not configured/initialized."); return "Error: Claim generation service misconfigured."; }
    if (!question || question.trim() === '') { return "Error: Cannot generate claim for empty question."; }

    await waitForRateLimit(requestContext);
    console.log(`[Generator Service Request: ${requestContext?.substring(0, 10)}...] Requesting CLAIM generation...`);
    const systemPrompt = 'Based on the QUESTION, provide a concise, verifiable factual claim that answers the question. Output only the claim.';
    const payload = { model: MODEL_IDENTIFIER, messages: [{ role: "system", content: systemPrompt }, { role: "user", content: `QUESTION: "${question}"\n\nCLAIM:` }], max_tokens: MAX_TOKENS_CLAIM, temperature: TEMPERATURE_CLAIM, top_p: 0.9, };

    try {
        const response = await axios.post(OPENROUTER_API_URL, payload, { headers: { 'Authorization': `Bearer ${API_KEY}`, 'Content-Type': 'application/json', 'HTTP-Referer': `http://localhost:${config.port || 3001}`, 'X-Title': 'Kintask ClaimGen', }, timeout: 60000 });
        console.log(`[Generator Service Request: ${requestContext?.substring(0, 10)}...] Claim Gen API Call Successful | Status: ${response.status}`);
        const claim = response.data?.choices?.[0]?.message?.content?.trim().replace(/^CLAIM:\s*/i, '');
        if (!claim) { throw new Error("LLM returned empty claim content."); }
        console.log(`[Generator Service Request: ${requestContext?.substring(0, 10)}...] Generated Claim: "${truncateText(claim, 70)}"`);
        // --- Recall Log REMOVED ---
        return claim;
    } catch (error: any) {
        const axiosError = error as AxiosError; let detailedErrorMessage = axiosError.message.split('\n')[0]; let statusCode: number | string = 'N/A'; console.error(`\n--- ERROR in generateClaim ---`); if (axiosError.response) { statusCode = axiosError.response.status; console.error(`[...] Claim Gen API Call FAILED | Status: ${statusCode}`); console.error(`[...] Claim Gen Error Response Data:`, JSON.stringify(axiosError.response.data, null, 2)); detailedErrorMessage = (axiosError.response.data as any)?.error?.message || `HTTP Error ${statusCode}`; /* ... */ } else if (axiosError.request) { console.error(`[...] Claim Gen Network Error | Status: ${statusCode}`); } else { console.error(`[...] Claim Gen Setup Error | Status: ${statusCode} | Msg: ${detailedErrorMessage}`); } console.error(`[...] Final Error generating claim: ${detailedErrorMessage}`); console.error(`--- END ERROR in generateClaim ---\n`);
        // --- Recall Log REMOVED ---
        return `Error: Could not generate claim (${detailedErrorMessage.substring(0, 50)}...).`;
    }
}

// --- LLMVerificationResult Interface ---
export interface LLMVerificationResult { verdict: 'Supported' | 'Contradicted' | 'Neutral'; confidence: number; explanation?: string; }

// --- getVerificationFromLLM ---
export async function getVerificationFromLLM(
    claim: string, paperExcerpt: string, requestContext?: string, agentId?: string
): Promise<LLMVerificationResult> {
    if (!isGeneratorInitialized) initializeGenerator();
    if (!API_KEY || !isGeneratorInitialized) { console.error(`[Verifier Agent ${agentId} Error] LLM Verifier misconfigured.`); return { verdict: 'Neutral', confidence: 0.1, explanation: "Verifier LLM misconfigured." }; }
    await waitForRateLimit(requestContext, agentId);
    console.log(`[Verifier Agent ${agentId} Request: ${requestContext?.substring(0, 10)}...] Requesting LLM verification...`);
    const systemPrompt = `You are an AI evaluating scientific claims. Analyze the TEXT EXCERPT to determine if it supports, contradicts, or is neutral towards the CLAIM. Respond ONLY in the format:\nVerdict: [Supported|Contradicted|Neutral]\nConfidence: [0.0-1.0]\nExplanation: [1 sentence]`;
    const truncatedExcerpt = truncateText(paperExcerpt, 3000);
    const userPrompt = `CLAIM: "${claim}"\n\nTEXT EXCERPT:\n---\n${truncatedExcerpt}\n---\nBased *only* on the TEXT EXCERPT, evaluate the CLAIM.`;
    const payload = { model: MODEL_IDENTIFIER, messages: [{ role: "system", content: systemPrompt }, { role: "user", content: userPrompt }], max_tokens: MAX_TOKENS_VERIFY, temperature: TEMPERATURE_VERIFY, };
    console.log(`[Verifier Agent ${agentId} DEBUG] Attempting axios.post...`);
    try {
        const response = await axios.post(OPENROUTER_API_URL, payload, { headers: { /* ... */ }, timeout: 45000 });
        console.log(`[Verifier Agent ${agentId} Request: ${requestContext?.substring(0, 10)}...] Verify LLM API Call Successful | Status: ${response.status}`);
        const content = response.data?.choices?.[0]?.message?.content?.trim();
        if (!content) { throw new Error("LLM Verifier returned empty content."); }
        let verdict: 'Supported' | 'Contradicted' | 'Neutral' = 'Neutral'; let confidence = 0.5; let explanation = "Could not parse."; const verdictMatch = content.match(/Verdict:\s*(Supported|Contradicted|Neutral)/i); const confidenceMatch = content.match(/Confidence:\s*([0-9.]+)/i); const explanationMatch = content.match(/Explanation:\s*(.*)/i);
        if (verdictMatch?.[1]) { const fv = verdictMatch[1].charAt(0).toUpperCase() + verdictMatch[1].slice(1).toLowerCase(); if (fv === 'Supported' || fv === 'Contradicted' || fv === 'Neutral') { verdict = fv; } }
        if (confidenceMatch?.[1]) { const pc = parseFloat(confidenceMatch[1]); if (!isNaN(pc) && pc >= 0 && pc <= 1) { confidence = pc; } }
        if (explanationMatch?.[1]) { explanation = explanationMatch[1].trim(); }
        return { verdict, confidence: parseFloat(confidence.toFixed(2)), explanation };
    } catch (error: any) {
        const axiosError = error as AxiosError; let detailedErrorMessage = axiosError.message.split('\n')[0]; let statusCode: number | string = 'N/A'; console.error(`\n--- ERROR in getVerificationFromLLM (Agent: ${agentId}) ---`); if (axiosError.response) { /* ... */ } else if (axiosError.request) { /* ... */ } else { /* ... */ } console.error(`[...] Final Error for LLM call: ${detailedErrorMessage}`); console.error(`--- END ERROR ---\n`);
        // --- Recall Log REMOVED ---
        return { verdict: 'Neutral', confidence: 0.1, explanation: `LLM API Error: ${detailedErrorMessage}` };
    }
}===== ./recallService.ts =====
// services/recallService.ts
import config from '../config';
import { RecallLogEntryData, RecallEventType, VerificationResultInternal } from '../types';
import { testnet } from '@recallnet/chains';
import {
    createWalletClient, http, parseEther, WalletClient, PublicClient, createPublicClient,
    ChainMismatchError, BaseError, ContractFunctionExecutionError, formatEther, Address
} from 'viem';
import { privateKeyToAccount, Account } from 'viem/accounts';
import { RecallClient } from '@recallnet/sdk/client';
import { truncateText } from '../utils';

// --- Module State ---
let recallClientInstance: RecallClient | null = null;
let isRecallInitialized = false;
let logBucketAddress: Address | null = config.recallLogBucket ? config.recallLogBucket as Address : null;
let account: Account | null = null;
const RECALL_BUCKET_ALIAS = 'kintask-log-bucket-v1';
let initPromise: Promise<RecallClient> | null = null;
let isProcessingTx = false;
const txQueue: (() => Promise<any>)[] = [];
// Track buckets approved in this session to avoid redundant transactions
const approvedBuckets = new Set<Address>();

// --- Helper: Create Viem Wallet Client ---
function getWalletClient(): WalletClient {
    if (!config.recallPrivateKey) {
        throw new Error('Recall Private Key (RECALL_PRIVATE_KEY in .env) is not configured.');
    }
    const formattedPrivateKey = config.recallPrivateKey.startsWith('0x')
        ? config.recallPrivateKey as `0x${string}`
        : `0x${config.recallPrivateKey}` as `0x${string}`;

    if (!account) {
        account = privateKeyToAccount(formattedPrivateKey);
        console.log(`[Recall Service] Using wallet: ${account.address} | Chain: ${testnet.id}`);
    }
    return createWalletClient({
        account: account,
        chain: testnet,
        transport: http(/*testnet.rpcUrls.default.http[0]*/),
    });
}

// --- Helper: Create Viem Public Client ---
function getPublicClient(): PublicClient {
    return createPublicClient({
        chain: testnet,
        transport: http(),
    });
}


// --- Helper: Get or Initialize Recall Client (Singleton Pattern) ---
async function getRecallClient(): Promise<RecallClient> {
    if (recallClientInstance && isRecallInitialized) {
        return recallClientInstance;
    }
    if (initPromise) {
        return initPromise;
    }
    initPromise = (async () => {
        console.log("[Recall Service] Initializing Client...");
        try {
            const walletClient = getWalletClient();
            const client = new RecallClient({ walletClient });
            if (!client.walletClient.account?.address) {
                throw new Error("Wallet address missing after client initialization.");
            }
            console.log("[Recall Service] Client Initialized successfully.");
            recallClientInstance = client; isRecallInitialized = true; initPromise = null; return client;
        } catch (error: any) {
            const conciseError = (error instanceof Error) ? error.message.split('\n')[0] : String(error);
            console.error("[Recall Service] FATAL ERROR initializing Recall Client:", conciseError);
            recallClientInstance = null; isRecallInitialized = false; initPromise = null;
            throw new Error(`Recall Client initialization failed: ${conciseError}`);
        }
    })();
    return initPromise;
}

// --- Transaction Queue (Simple Nonce Management) ---
async function processTxQueue<T>(txFunction: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
        const runTx = async () => {
            if (isProcessingTx) {
                txQueue.push(runTx);
                return;
            }
            isProcessingTx = true;
            try {
                // console.log("[Recall Tx Queue] Executing transaction..."); // Keep less verbose
                const result = await txFunction();
                // console.log("[Recall Tx Queue] Transaction finished.");
                resolve(result);
            } catch (err: any) {
                const errMsg = err?.shortMessage || err?.message || String(err);
                console.error("[Recall Tx Queue] Transaction error:", errMsg.split('\n')[0]);
                reject(err);
            } finally {
                isProcessingTx = false;
                const nextTx = txQueue.shift();
                if (nextTx) {
                    console.log(`[Recall Tx Queue] Processing next queued tx (${txQueue.length} remaining)...`);
                    setImmediate(() => { // Use setImmediate for async queue processing
                        nextTx().catch(queueError => {
                            const qErrMsg = queueError?.shortMessage || queueError?.message || String(queueError);
                            console.error("[Recall Tx Queue] Error processing subsequent queued tx:", qErrMsg.split('\n')[0]);
                        });
                    });
                }
            }
        };
        if (!isProcessingTx && txQueue.length === 0) {
            runTx();
        } else {
            console.log(`[Recall Tx Queue] Queuing transaction (${txQueue.length + 1} in queue)...`);
            txQueue.push(runTx);
        }
    });
}


// --- Credits and Bucket Management ---
async function ensureCreditBalance(recall: RecallClient): Promise<void> {
    console.log("[Recall Service] MOCK: Checking credit balance... (No actual check performed)");
    // Mock successful credit balance
    console.log(`[Recall Service] MOCK: Credit balance sufficient. (No actual verification)`);
    return;
}


// --- Ensure Bucket Approval ---
async function ensureBucketApproval(recall: RecallClient, bucketAddress: Address): Promise<void> {
    console.log(`[Recall Service] MOCK: Ensuring credit approval for bucket ${bucketAddress.substring(0, 10)}... (No actual approval)`);
    approvedBuckets.add(bucketAddress); // Mock approval
    return;
}


async function ensureLogBucket(recall: RecallClient): Promise<Address> {
    if (logBucketAddress) { return logBucketAddress; }
    console.log(`[Recall Service] MOCK: Ensuring log bucket (Alias: ${RECALL_BUCKET_ALIAS})... (No actual bucket creation)`);
    // Mock a bucket address if one isn't configured
    const mockBucketAddress = '0xMockBucket123456789012345678901234567890' as Address;
    logBucketAddress = mockBucketAddress;
    console.log(`[Recall Service] MOCK: Using mock bucket address: ${logBucketAddress}`);
    return logBucketAddress;
}

// --- Core Function to Add Object ---
export async function addObjectToBucket(
    dataObject: object, key: string
): Promise<{ success: boolean, bucket?: string, key?: string, txHash?: string, error?: string }> {
    // Create mock bucket address for consistent logging
    const mockBucketAddr = "0xMockBucket123456789012345678901234567890";

    console.log(`[Recall Service] MOCK: Would store object | Bucket: ${mockBucketAddr.substring(0, 10)}... | Key: ${truncateText(key, 40)}...`);
    console.log(`[Recall Service] MOCK: Object content:`, JSON.stringify(dataObject, null, 2));
    
    // Return mock success response
    return { 
        success: true, 
        bucket: mockBucketAddr, 
        key: key, 
        txHash: "0xMockTxHash123456789012345678901234567890" 
    };
}

// --- Function for logging CRITICAL errors ---
export async function logErrorEvent(
    details: Record<string, any>, requestContext: string
): Promise<string | undefined> {
    if (!requestContext) { 
        console.error("[Recall Service] CRITICAL: logErrorEvent missing requestContext."); 
        return undefined; 
    }

    const logEntry = { 
        timestamp: new Date().toISOString(), 
        type: 'VERIFICATION_ERROR' as RecallEventType, 
        details, 
        requestContext 
    };
    
    const timestampSuffix = logEntry.timestamp.replace(/[:.]/g, '-').replace('T', '_').replace('Z', '');
    const key = `${requestContext}/ERROR_${details.stage || 'Unknown'}_${timestampSuffix}.json`;
    
    console.log(`[Recall Service] MOCK: Would log ERROR event with key: ${key}`);
    console.log(`[Recall Service] MOCK: Error log content:`, JSON.stringify(logEntry, null, 2));
    
    return "0xMockErrorTxHash123456789012345678901234567890";
}

// --- Function for the FINAL batch log ---
export async function logFinalVerificationTrace(
    requestContext: string, verificationResult: VerificationResultInternal
): Promise<string | undefined> {
    if (!requestContext || !verificationResult) { 
        console.error("[Recall Service] Missing context or result for final batch log."); 
        return undefined; 
    }

    const logType: RecallEventType = verificationResult.finalVerdict.startsWith('Error:') ? 'VERIFICATION_ERROR' : 'VERIFICATION_COMPLETE';
    const finalLogObject = {
        timestamp: new Date().toISOString(), 
        type: logType, 
        requestContext: requestContext,
        finalVerdict: verificationResult.finalVerdict, 
        finalConfidence: verificationResult.confidenceScore,
        timelockRequestId: verificationResult.timelockRequestId, 
        timelockCommitTxHash: verificationResult.timelockCommitTxHash,
        usedEvidenceCids: verificationResult.usedFragmentCids,
        fullTrace: verificationResult.reasoningSteps // Store the full trace array
    };
    
    const timestampSuffix = finalLogObject.timestamp.replace(/[:.]/g, '-').replace('T', '_').replace('Z', '');
    const key = `${requestContext}/FINAL_TRACE_${logType}_${timestampSuffix}.json`;
    
    console.log(`[Recall Service] MOCK: Would log FINAL BATCH with key: ${key}`);
    console.log(`[Recall Service] MOCK: Final batch content:`, JSON.stringify(finalLogObject, null, 2));
    
    return "0xMockFinalTraceTxHash123456789012345678901234567890";
}

// --- Trace Retrieval Function ---
export async function getTraceFromRecall(requestContext: string): Promise<RecallLogEntryData[]> {
    if (!requestContext) return [];
    
    console.log(`[Recall Service] MOCK: Would retrieve trace blobs | Context: ${requestContext.substring(0, 10)}...`);
    console.log(`[Recall Service] MOCK: Returning empty array (no actual retrieval)`);
    
    // Return empty array since we're not actually retrieving anything
    return [];
}===== ./repo_contents.txt =====
===== ./timelockService.ts =====
// ./src/services/timelockService.ts
import { ethers, Wallet, Contract, utils, providers, BigNumber, Event } from 'ethers'; // Use v5 imports
import { Blocklock, SolidityEncoder, encodeCiphertextToSolidity, TypesLib } from 'blocklock-js';
import config from '../config';
// @ts-ignore - Assume JSON ABI is correct
import KintaskCommitmentAbi from '../contracts/abi/KintaskCommitment.json';
import { KINTASK_COMMITMENT_CONTRACT_ADDRESS } from '../contracts/addresses';
import { logRecallEvent } from './recallService'; // Import recall logger for reveal events

interface CommitResult {
    requestId: string;
    txHash: string;
    ciphertextHash: string;
}

// --- Initialization ---
let provider: providers.StaticJsonRpcProvider | null = null;
let wallet: Wallet | null = null;
let blocklockJsInstance: Blocklock | null = null;
let commitmentContract: Contract | null = null;
let isTimelockInitialized = false;
let revealListenerAttached = false;
const blocklockIdToRequestContext = new Map<string, string>();
const MAX_CONTEXT_MAP_SIZE = 1000;

// Function to initialize (or re-initialize) the service
function initializeTimelockService(): boolean {
    if (isTimelockInitialized) return true;
    console.log("[Timelock Service] Initializing...");
    try {
        if (!config.l2RpcUrl || !config.walletPrivateKey || !config.blocklockSenderProxyAddress || !KINTASK_COMMITMENT_CONTRACT_ADDRESS) {
             console.warn("[Timelock Service] Skipping initialization: Missing required config.");
             return false;
         }
          // @ts-ignore
          if (!KintaskCommitmentAbi.abi || KintaskCommitmentAbi.abi.length === 0) {
               console.error("[Timelock Service] FATAL ERROR: KintaskCommitment ABI missing.");
               return false;
          }

        provider = new providers.StaticJsonRpcProvider(config.l2RpcUrl);
        wallet = new Wallet(config.walletPrivateKey, provider);

        import('blocklock-js').then(BlocklockModule => {
            blocklockJsInstance = new BlocklockModule.Blocklock(wallet!, config.blocklockSenderProxyAddress!);
             // @ts-ignore
             commitmentContract = new Contract(KINTASK_COMMITMENT_CONTRACT_ADDRESS!, KintaskCommitmentAbi.abi, wallet);

             Promise.all([
                 provider!.getNetwork(),
                 // --- FIX: Use contract.address property (ethers v5) ---
                 Promise.resolve(commitmentContract.address) // Resolve address property
                 // --- END FIX ---
             ]).then(async ([network, address]) => { // Mark async to await getBlockNumber
                 console.log(`[Timelock Service] Connected to network: ${network.name} (Chain ID: ${network.chainId})`);
                 console.log(`[Timelock Service] Contract instance connected at: ${address}`); // address is now directly the string
                 try {
                    // Initialize lastPolledBlock - this part remains the same
                    // @ts-ignore TODO: Remove polling or fix getBlockNumber call if needed
                    // lastPolledBlock = await provider!.getBlockNumber();
                    // console.log(`[Timelock Service] Initial polling block set to: ${lastPolledBlock}`);
                    isTimelockInitialized = true;
                    console.log("[Timelock Service] Initialization complete.");
                    startRevealListener(); // Start listener
                } catch (blockNumError: any) {
                    console.error("[Timelock Service] Failed to get initial block number:", blockNumError.message);
                    isTimelockInitialized = false;
                }
             }).catch(err => {
                 console.error("[Timelock Service] Post-init check failed:", err.message);
                 isTimelockInitialized = false;
             });
        }).catch(importError => {
            console.error("[Timelock Service] FATAL: Failed to import blocklock-js:", importError);
            isTimelockInitialized = false;
        });

         console.log("[Timelock Service] Initialization sequence started...");
         return true;

    } catch (error: any) {
         console.error("[Timelock Service] FATAL Initialization failed:", error.message);
         isTimelockInitialized = false;
         return false;
    }
}

// Attempt initialization on module load
initializeTimelockService();

// --- Commit Function ---
export async function commitVerdictTimelocked(
    verdict: string,
    delayInBlocks: number = 5,
    requestContext?: string
): Promise<CommitResult | null> {

    if (!isTimelockInitialized || !blocklockJsInstance || !commitmentContract || !provider || !wallet) {
        console.error('[Timelock Service] Service not initialized or ready. Cannot commit verdict.');
        return null;
    }

    let txResponse: providers.TransactionResponse | null = null;
    const logContext = requestContext || 'unknownContext';

    try {
        const currentBlockNumber = await provider.getBlockNumber();
        const decryptionBlockNumber = BigNumber.from(currentBlockNumber + delayInBlocks);
        console.log(`[Timelock Service Context: ${logContext}] Current Block: ${currentBlockNumber}, Decryption Block Target: ${decryptionBlockNumber.toString()}`);

        const encoder = utils.defaultAbiCoder;
        const encodedVerdict = encoder.encode(['string'], [verdict]);
        const encodedVerdictBytes = utils.arrayify(encodedVerdict);

        console.log(`[Timelock Service Context: ${logContext}] Encrypting verdict "${verdict}"`);
        const ciphertext: TypesLib.Ciphertext = blocklockJsInstance.encrypt(encodedVerdictBytes, BigInt(currentBlockNumber + delayInBlocks));

        const { encodeCiphertextToSolidity } = await import('blocklock-js');
        const solidityCiphertext = encodeCiphertextToSolidity(ciphertext);
        const ciphertextHash = utils.keccak256(solidityCiphertext.v);
        console.log(`[Timelock Service Context: ${logContext}] Ciphertext Hash: ${ciphertextHash}`);

        // --- FIX: Use contract.address property (ethers v5) ---
        const contractAddress = commitmentContract.address;
        console.log(`[Timelock Service Context: ${logContext}] Sending commitVerdict transaction to ${contractAddress}...`);
        // --- END FIX ---

        // Optional Gas Estimation (v5 uses estimateGas property on the function)
        let estimatedGas: BigNumber | undefined;
        try {
            estimatedGas = await commitmentContract.estimateGas.commitVerdict(
                 decryptionBlockNumber,
                 solidityCiphertext
            );
            console.log(`[Timelock Service DEBUG] Estimated Gas: ${estimatedGas.toString()}`);
        } catch (simError: any) {
            let reason = simError.reason || simError.message;
             // v5 error data might be different, simpler check
             if (simError.error?.data?.message) { reason = simError.error.data.message; }
            console.error(`[Timelock Service DEBUG] Gas estimation/simulation FAILED: ${reason}`);
            throw new Error(`Transaction simulation/estimation failed: ${reason}`);
        }

        txResponse = await commitmentContract.commitVerdict(
            decryptionBlockNumber,
            solidityCiphertext,
            // Apply gas limit bump if estimation worked
            { gasLimit: estimatedGas ? estimatedGas.mul(120).div(100) : undefined }
        );

        if (!txResponse) {
            throw new Error("commitVerdict call returned null response.");
        }

        console.log(`[Timelock Service Context: ${logContext}] Commit transaction sent. Hash: ${txResponse.hash}`);
        console.log(`[Timelock Service Context: ${logContext}] Waiting for confirmation (1 block)...`);
        const receipt: providers.TransactionReceipt | null = await txResponse.wait(1);

        if (!receipt) {
             throw new Error(`Commit transaction ${txResponse?.hash ?? 'unknown'} confirmation timed out or receipt was null.`);
         }

        console.log(`[Timelock Service Context: ${logContext}] Commit Tx Confirmed. Status: ${receipt.status}, Block: ${receipt.blockNumber}`);
        if (receipt.status !== 1) {
            throw new Error(`Commit transaction ${txResponse?.hash ?? 'unknown'} failed on-chain (Status: 0). Check explorer.`);
        }

        const eventInterface = commitmentContract.interface;
        const eventSignature = 'VerdictCommitted(uint256,address,uint256,bytes32)';
        const eventTopic = eventInterface.getEventTopic(eventSignature);
        const receiptLogs = receipt.logs || [];
        const log = receiptLogs.find((l) =>
            l.topics[0] === eventTopic &&
            l.address.toLowerCase() === KINTASK_COMMITMENT_CONTRACT_ADDRESS!.toLowerCase()
        );

        if (!log) {
            throw new Error(`Could not find VerdictCommitted event log in transaction receipt for ${txResponse?.hash ?? 'unknown'}.`);
        }
        const decodedLog = eventInterface.parseLog(log);
        const blocklockRequestId = decodedLog?.args.blocklockRequestId?.toString();
        if (!blocklockRequestId) throw new Error('Failed to decode Blocklock Request ID from VerdictCommitted event.');
        console.log(`[Timelock Service Context: ${logContext}] Successfully committed. Blocklock Request ID: ${blocklockRequestId}`);

        if (requestContext) {
            if (blocklockIdToRequestContext.size >= MAX_CONTEXT_MAP_SIZE) {
                const oldestKey = blocklockIdToRequestContext.keys().next().value;
                if (oldestKey !== undefined) {
                    blocklockIdToRequestContext.delete(oldestKey);
                    console.warn(`[Timelock Service] Context map size limit reached, removed oldest entry: ${oldestKey}`);
                }
            }
            blocklockIdToRequestContext.set(blocklockRequestId, requestContext);
            console.log(`[Timelock Service] Mapped Blocklock ID ${blocklockRequestId} to Context ${requestContext}`);
        } else { console.warn("[Timelock Service] Request context not provided for mapping reveal listener."); }

        return {
            requestId: blocklockRequestId,
            txHash: txResponse?.hash ?? 'unknown_hash',
            ciphertextHash: ciphertextHash
        };

    } catch (error: any) {
        console.error(`[Timelock Service Error Context: ${logContext}] Error during commit:`, error.message);
        if (txResponse?.hash) console.error(`[Timelock Service] Failing Transaction Hash: ${txResponse.hash}`);
        return null;
    }
}

// --- Reveal Listener ---
export function startRevealListener() {
    if (revealListenerAttached) { return; }
     if (!isTimelockInitialized || !commitmentContract) {
         console.warn("[Timelock Service] Cannot start listener, service not fully initialized yet.");
         return;
     }

    console.log(`[Timelock Service] Attaching listener for VerdictRevealed events on contract ${KINTASK_COMMITMENT_CONTRACT_ADDRESS}...`);
    try {
        const eventFilter = commitmentContract.filters.VerdictRevealed();

         commitmentContract.on(eventFilter, async (requestIdBigNumber, requester, revealedVerdictBytes, event: Event) => {
            const blocklockRequestId = requestIdBigNumber.toString();
            const txHash = event.transactionHash;

            console.log(`\n[Timelock Listener] === Received VerdictRevealed Event ===`);
            console.log(`  Blocklock Request ID: ${blocklockRequestId}`);
            console.log(`  Event Source Tx Hash: ${txHash}`);

             const requestContext = blocklockIdToRequestContext.get(blocklockRequestId);
             if (!requestContext) {
                 console.warn(`[Timelock Listener] Could not find request context for revealed Blocklock ID: ${blocklockRequestId}.`);
                 return;
             }
             console.log(`  Associated Request Context: ${requestContext}`);
             blocklockIdToRequestContext.delete(blocklockRequestId);

             try {
                const encoder = utils.defaultAbiCoder;
                const [revealedVerdict] = encoder.decode(['string'], revealedVerdictBytes);
                console.log(`[Timelock Listener] Decoded Verdict for context ${requestContext}: "${revealedVerdict}"`);

                await logRecallEvent(
                    'TIMELOCK_REVEAL_RECEIVED',
                    { blocklockRequestId, revealedVerdict, sourceTxHash: txHash, requester },
                    requestContext
                );
                console.log(`[Timelock Listener] Logged TIMELOCK_REVEAL_RECEIVED to Recall for context ${requestContext}`);
             } catch(decodeError: any) {
                console.error(`[Timelock Listener] Error decoding revealed verdict for ID ${blocklockRequestId}, Context ${requestContext}:`, decodeError.message);
                 await logRecallEvent(
                    'VERIFICATION_ERROR',
                    { stage: 'TimelockRevealDecode', error: decodeError.message, blocklockRequestId, rawBytes: utils.hexlify(revealedVerdictBytes) },
                    requestContext
                );
             }
         });

        revealListenerAttached = true;
        console.log("[Timelock Service] Listener attached successfully.");

    } catch (error: any) {
        console.error("[Timelock Service] Failed to attach listener:", error.message);
        revealListenerAttached = false;
    }
}

// Function to stop listener
export function stopRevealListener() {
     if (revealListenerAttached && commitmentContract) {
         console.log("[Timelock Service] Removing VerdictRevealed listener...");
         try {
             commitmentContract.removeAllListeners("VerdictRevealed");
             revealListenerAttached = false;
             console.log("[Timelock Service] Listener removed.");
         } catch (error: any) {
             console.error("[Timelock Service] Error removing listener:", error.message);
             revealListenerAttached = false;
         }
     }
}===== ./verifierService.ts =====
// services/verifierService.ts
import {
    VerificationResultInternal,
    RecallLogEntryData,
    RecallEventType,
    VerificationStatus
} from '../types';
import { fetchKnowledgeSourceContent } from './filecoinService';
import { commitVerdictTimelocked } from './timelockService';
// --- Import ONLY the final batch log function ---
import { logFinalVerificationTrace, logErrorEvent } from './recallService'; // Keep logErrorEvent for critical agent fails
import { truncateText } from '../utils';
import config from '../config';
import { getVerificationFromLLM, LLMVerificationResult } from './generatorService';
import { ethers } from 'ethers';

type AgentVerdict = 'Supported' | 'Contradicted' | 'Neutral';
interface AgentVerificationResult {
    verdict: AgentVerdict; confidence: number; evidenceCid: string; agentId: string; explanation?: string;
}
const NUM_VERIFIER_AGENTS = 1;
const CONSENSUS_THRESHOLD = 0.6;

// addStep helper - PURELY LOCAL LOGGING
const addStep = (
    reasoningSteps: RecallLogEntryData[], requestContext: string, type: RecallEventType, details: Record<string, any>) => {
    if (!Array.isArray(reasoningSteps)) { console.error(`[addStep INTERNAL ERROR]`); return; }
    const timestamp = new Date().toISOString();
    const truncatedDetails = Object.entries(details).reduce((acc, [key, value]) => {
        try { /* ... truncation ... */ } catch (e) { /* ... */ } return acc;
    }, {} as Record<string, any>);
    const stepData: RecallLogEntryData = { timestamp, type, details: truncatedDetails, requestContext };
    reasoningSteps.push(stepData);
};

// LLM Verifier Agent - PURELY LOCAL LOGGING via addStep
async function LLMVerifierAgent(
    claim: string, paperContent: string, agentId: string, requestContext: string, reasoningSteps: RecallLogEntryData[]
): Promise<{ success: boolean; result?: AgentVerificationResult; error?: string }> {
    if (!Array.isArray(reasoningSteps)) { /* ... */ return { success: false, error:"Internal error", agentId }; }
    addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'VerifierAgentStart', agentId }); // Log locally
    const paperCid = config.knowledgeBaseIndexCid || 'unknown_cid';
    try {
        const relevantText = `Abstract:\n${paperContent.substring(0, 1500)}\n\nConclusion:\n${paperContent.substring(Math.max(0, paperContent.length - 1500))}`;
        addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'VerifierAgentLLMCall', agentId }); // Log locally
        const llmResult: LLMVerificationResult = await getVerificationFromLLM(claim, relevantText, requestContext, agentId);
        const result: AgentVerificationResult = { verdict: llmResult.verdict, confidence: llmResult.confidence, evidenceCid: paperCid, agentId: agentId, explanation: llmResult.explanation };
        addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'VerifierAgentComplete', agentId, verdict: result.verdict, /*...*/ }); // Log locally
        // --- NO Recall Log here ---
        console.log(`[Verifier Agent ${agentId} DEBUG] Finished successfully.`);
        return { success: true, result: result };
    } catch (error: any) {
        const conciseError = error instanceof Error ? error.message.split('\n')[0] : String(error);
        console.error(`[Verifier Agent ${agentId} Error] ${conciseError}`);
        addStep(reasoningSteps, requestContext, 'VERIFICATION_ERROR', { stage: 'VerifierAgentExecution', agentId, error: conciseError }); // Log locally
        // --- Log critical agent error to Recall ---
        logErrorEvent({ stage: 'VerifierAgentExecution', agentId, error: conciseError }, requestContext).catch(/* ignore background log fail */);
        return { success: false, error: conciseError, agentId };
     }
}


// --- Main Verification Logic Function ---
export async function performVerification(
    question: string, initialClaim: string, requestContext: string
): Promise<VerificationResultInternal | null> {

    console.log(`[Verifier Service] Starting verification | Context: ${requestContext.substring(0,10)}...`);
    const reasoningSteps: RecallLogEntryData[] = []; // Initialize local log array
    let finalEvidenceCids: string[] = []; let finalVerdict: VerificationStatus = 'Unverified'; let finalConfidence = 0.0;
    let timelockDetails: Awaited<ReturnType<typeof commitVerdictTimelocked>> = null;

    addStep(reasoningSteps, requestContext, 'VERIFICATION_START', { inputQuestion: truncateText(question, 100), initialClaim: truncateText(initialClaim, 100) });

    try {
        addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'AnalyzeInput' });
        addStep(reasoningSteps, requestContext, 'KNOWLEDGE_FETCH_ATTEMPT', { stage: 'PaperContent' });
        const paperText = await fetchKnowledgeSourceContent();

        if (!paperText) {
            addStep(reasoningSteps, requestContext, 'VERIFICATION_ERROR', { stage: 'PaperFetch', error: 'Failed' });
            finalVerdict = 'Error: Verification Failed';
        } else {
            addStep(reasoningSteps, requestContext, 'KNOWLEDGE_FETCH_SUCCESS', { /* ... */ });
            const paperCid = config.knowledgeBaseIndexCid || 'unknown_cid';
            const verifierPromises = [];
            addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'SimulateVerifierAgentsLLM', count: NUM_VERIFIER_AGENTS });
            for (let i = 1; i <= NUM_VERIFIER_AGENTS; i++) { verifierPromises.push( LLMVerifierAgent(initialClaim, paperText, `verifier_${i}`, requestContext, reasoningSteps) ); }
            const settledResults = await Promise.allSettled(verifierPromises);

            addStep(reasoningSteps, requestContext, 'REASONING_STEP', { step: 'AggregateResultsLLM' });
            const successfulResults: AgentVerificationResult[] = [];
            settledResults.forEach((pResult, index) => { if (pResult.status === 'fulfilled' && pResult.value.success && pResult.value.result) { successfulResults.push(pResult.value.result); } else { addStep(reasoningSteps, requestContext, 'VERIFICATION_ERROR', { stage: 'VerifierCompletion', /* ... */ }); } });
            const successfulAgentsCount = successfulResults.length;

            // Aggregation Logic
            if (successfulAgentsCount < 1) { /*...*/ finalVerdict = 'Flagged: Uncertain'; finalConfidence = 0.1; finalEvidenceCids = [paperCid]; }
            else { /* Simplified for N=1 */ const r = successfulResults[0]; if (r.verdict === 'Supported') finalVerdict = 'Verified'; else if (r.verdict === 'Contradicted') finalVerdict = 'Flagged: Contradictory'; else finalVerdict = 'Unverified'; finalConfidence = r.confidence; finalEvidenceCids = [r.evidenceCid];}
            const verdictDetails = { step: 'AggregationComplete', aggregatedVerdict: finalVerdict, aggregatedConfidence: finalConfidence.toFixed(2), successfulAgents: successfulAgentsCount };
            addStep(reasoningSteps, requestContext, 'REASONING_STEP', verdictDetails); // Log locally
            // NO Recall log here for intermediate verdict
        }

        // Timelock Commit (use addStep locally)
        if (config.kintaskContractAddress && config.blocklockSenderProxyAddress) {
            addStep(reasoningSteps, requestContext, 'TIMELOCK_COMMIT_ATTEMPT', { verdictToCommit: finalVerdict });
             if (!finalVerdict.startsWith('Error:')) {
                 timelockDetails = await commitVerdictTimelocked(finalVerdict, 5, requestContext);
                 if (timelockDetails) { addStep(reasoningSteps, requestContext, 'TIMELOCK_COMMIT_SUCCESS', { /*...*/ }); }
                 else { addStep(reasoningSteps, requestContext, 'TIMELOCK_COMMIT_FAILURE', { /*...*/ }); finalVerdict = 'Error: Timelock Failed'; finalConfidence = 0;}
             } else { addStep(reasoningSteps, requestContext, 'TIMELOCK_COMMIT_FAILURE', { /*...*/ }); }
        } else { addStep(reasoningSteps, requestContext, 'TIMELOCK_COMMIT_FAILURE', { /*...*/ }); }

        // Final Result Object Construction
        addStep(reasoningSteps, requestContext, 'VERIFICATION_COMPLETE', { finalStatus: finalVerdict }); // Log completion locally
        const finalResult: VerificationResultInternal = {
            finalVerdict: finalVerdict, confidenceScore: parseFloat(finalConfidence.toFixed(2)), usedFragmentCids: finalEvidenceCids,
            reasoningSteps: reasoningSteps, // Include local steps
            timelockRequestId: timelockDetails?.requestId, timelockCommitTxHash: timelockDetails?.txHash, ciphertextHash: timelockDetails?.ciphertextHash };

        // --- FINAL BATCH RECALL LOG ---
        console.log(`[Verifier Service] Attempting FINAL BATCH log | Steps: ${reasoningSteps.length}`);
        await logFinalVerificationTrace(requestContext, finalResult) // Use dedicated batch function
             .then(txHash => { if(txHash) console.log(`[Verifier Service] Final batch logged | Tx: ${txHash.substring(0,15)}...`); })
             .catch(err => console.error(`[Verifier Service] FAILED final batch log: ${err.message}`));

        console.log(`[Verifier Service] Verification complete | Verdict: ${finalResult.finalVerdict}`);
        return finalResult; // Return object containing local reasoningSteps

    } catch (error: any) {
        const conciseError = error instanceof Error ? error.message.split('\n')[0] : String(error);
        console.error(`[Verifier Service Error - Top Level] ${conciseError}`);
        addStep(reasoningSteps, requestContext, 'VERIFICATION_ERROR', { error: conciseError, stage: 'TopLevelCatch' });
        const errorResult: VerificationResultInternal = { finalVerdict: 'Error: Verification Failed', confidenceScore: 0, usedFragmentCids: finalEvidenceCids, reasoningSteps: reasoningSteps, /*...*/ };
        try { await logFinalVerificationTrace(requestContext, errorResult); } catch {} // Log error batch
        return errorResult;
     }
}