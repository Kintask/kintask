// types/index.ts

import { Address } from 'viem'; // Import Address type if not already imported

// --- Knowledge Fragment Types ---
export interface KnowledgeFragmentProvenance {
    sourceType?: 'research_paper' | 'web_page' | 'user_upload' | 'derived';
    sourceUri?: string;
    retrievalDate?: string; // ISO 8601
    originalAuthor?: string;
    publicationDate?: string;
}
export interface ExternalAttestation {
    attestorId: string;
    claimCid: string;
    verdict: 'Supported' | 'Contradicted' | 'Neutral';
    confidence?: number;
    timestamp: string; // ISO 8601
    signature?: string;
}
export interface KnowledgeFragment {
    cid: string;
    content: string;
    metadata?: { title?: string; keywords?: string[]; chunkIndex?: number; };
    provenance?: KnowledgeFragmentProvenance;
    attestations?: ExternalAttestation[];
    embedding?: number[];
}

// --- LLM Verification Result Structure ---
export interface LLMVerificationResult {
    verdict: 'Supported' | 'Contradicted' | 'Neutral'; // For claim verification
    confidence: number; // 0.0 - 1.0
    explanation?: string; // Brief explanation
}
export interface LLMEvaluationResult {
    evaluation: 'Correct' | 'Incorrect' | 'Uncertain'; // For answer evaluation
    confidence: number; // 0.0 - 1.0
    explanation?: string; // Brief explanation
}

// --- Verification Status (Final outcome of evaluation/aggregation) ---
export type VerificationStatus =
    | 'Verified'
    | 'Unverified'
    | 'Flagged: Contradictory'
    | 'Flagged: Uncertain'
    | 'Error: Verification Failed'
    | 'Error: Aggregation Failed'
    | 'Error: Timelock Failed';

// --- Asynchronous Job Statuses (Used in Recall objects & Status API) ---
// Added 'PayoutAttemptedWithErrors' for clarity
export type JobStatus =
    | 'PendingAnswer'
    | 'PendingEvaluation'
    | 'EvaluationInProgress'
    | 'PendingPayout'
    | 'PayoutInProgress'
    | 'PayoutComplete'
    | 'Completed' // Generic completed state (could encompass PayoutComplete or NoValidAnswers)
    | 'NoValidAnswers' // Specifically means no answers were found or eligible after eval
    | 'PayoutAttemptedWithErrors' // Payout was tried but had FVM errors
    | 'Error'; // Generic error state

// --- Data Structures Stored in Recall ---

// QuestionData (from /ask endpoint)
// Stored at: reqs/{requestContext}/question.json
export interface QuestionData {
    question: string;
    cid: string; // CID of the knowledge base fragment used
    status: JobStatus; // Tracks the overall state of the request
    timestamp: string; // ISO 8601 when the question was submitted
    requestContext: string; // Unique ID for the entire request flow
    userId?: string; // Optional identifier for the user asking
    paymentUID?: string; // UID of the ERC20PaymentStatement attestation
    paymentRef?: string; // Optional reference string related to payment
    callbackUrl?: string; // Optional URL to notify upon completion/error
    user?: string // MetaMaskWallet
}

// AnswerData (submitted by agents)
// Stored at: reqs/{requestContext}/answers/{agentId}.json
export interface AnswerData {
    answer: string; // The actual answer text generated by the agent
    answeringAgentId: Address; // Ethereum address of the agent
    status: 'Submitted'; // Simple status for the answer itself
    timestamp: string; // ISO 8601 when the answer was submitted
    requestContext: string; // Links back to the original question
    confidence?: number; // Agent's self-reported confidence (optional)
    modelUsed?: string; // LLM model used by the agent (optional)
    fulfillmentUID: string | null; // UID of the *AnswerStatement* attestation <<< Keep original name but clarify meaning
    validationUID?: string | null; // UID of the *ZKPValidator* attestation <<< ADDED
}

// VerdictData (If separate verification step is used - currently not in main flow)
// Stored at: reqs/{requestContext}/verdicts/{verifierAgentId}.json
export interface VerdictData {
    verdict: 'Correct' | 'Incorrect' | 'Uncertain';
    confidence: number;
    explanation?: string;
    verifyingAgentId: Address;
    timestamp: string;
    requestContext: string;
    evidenceSnippets?: { startChar: number; endChar: number }[];
}

// EvaluationResult (output of backend evaluation)
// Stored at: reqs/{requestContext}/evaluation.json
export interface EvaluationResult {
    requestContext: string;
    results: Array<{ // Changed to Array<> syntax for consistency
        answeringAgentId: Address;
        answerKey: string; // Key where AnswerData is stored (e.g., reqs/.../answers/{agentId}.json)
        evaluation: 'Correct' | 'Incorrect' | 'Uncertain' | 'Error'; // LLM eval result + potential error state
        confidence: number; // LLM confidence
        explanation: string; // LLM explanation
        fulfillmentUID: string | null; // UID of the AnswerStatement attestation <<< Keep name
        validationUID?: string | null; // UID of the ZKPValidator attestation <<< ADDED
    }>;
    // Status reflects the outcome of the evaluation process *before* payout attempt
    status: 'PendingPayout' | 'NoValidAnswers' | 'Error' | 'PayoutComplete'; // Added PayoutComplete here too
    evaluatorAgentId: Address; // ID of the backend evaluator service
    timestamp: string; // ISO 8601 when evaluation was completed
    answerCount?: number; // Optional: total answers received
    correctCount?: number; // Optional: count deemed 'Correct' by LLM
}

// PayoutStatusData (logs the outcome of the payout process)
// Stored at: reqs/{requestContext}/payout.json
export interface PayoutStatusData {
    payoutAgentId: Address; // ID of the backend payout service
    payoutTimestamp: string; // ISO 8601 when payout process finished
    requestContext: string;
    stage: string; // More detailed stage (e.g., 'Start', 'PayoutComplete', 'PayoutAttemptedWithErrors', 'FatalError', 'Finalized-NoValidAnswers')
    success: boolean; // Overall success of the payout process for *this context*
    message: string; // Human-readable summary or error message
    txHashes: Record<string, string>; // Maps agent identifier/index to TX hash or error message
    processedAgents?: number; // How many answers were considered in evaluation
    correctAnswers?: number; // How many LLM deemed correct
    submissionsSent?: number; // How many collectPayment calls were successfully sent
    fvmErrors?: number; // How many collectPayment calls failed
}


// --- API Response for Status Check (`GET /api/status/{requestContext}`) ---
export interface RequestStatus {
    requestContext: string;
    status: JobStatus | 'Not Found' | 'Error'; // Overall status for the user
    question?: string;
    cid?: string;
    submittedAt: string; // Timestamp from QuestionData
    hasAnswers?: boolean;
    answerCount?: number;
    evaluationStatus?: EvaluationResult['status']; // Status from evaluation.json
    payoutStatus?: PayoutStatusData['stage']; // Use the more descriptive stage from payout.json
    payoutMessage?: string; // Message from payout.json
    finalVerdict?: VerificationStatus; // If applicable (not used in current flow)
    error?: string; // If overall status is Error
}


// --- Internal Result Structure (Sync Flow - Not primary focus here) ---
export interface VerificationResultInternal {
    finalVerdict: VerificationStatus;
    confidenceScore: number;
    usedFragmentCids: string[];
    reasoningSteps: RecallLogEntryData[];
    timelockRequestId?: string;
    timelockCommitTxHash?: string;
    ciphertextHash?: string;
    aggregationTxHash?: string;
}

// --- Recall Logging Event Types ---
export type RecallEventType =
    | 'QUESTION_LOGGED' | 'ANSWER_LOGGED' | 'VERDICT_LOGGED' | 'EVALUATION_LOGGED' | 'PAYOUT_LOGGED' | 'ERROR_LOGGED'
    | 'AGENT_POLL' | 'AGENT_JOB_START' | 'AGENT_KB_FETCH_START' | 'AGENT_KB_FETCH_SUCCESS' | 'AGENT_KB_FETCH_FAILURE'
    | 'AGENT_LLM_CALL_START' | 'AGENT_LLM_CALL_SUCCESS' | 'AGENT_LLM_CALL_FAILURE'
    | 'AGENT_FVM_CALL_START' | 'AGENT_FVM_CALL_SUCCESS' | 'AGENT_FVM_CALL_FAILURE' | 'AGENT_JOB_COMPLETE' | 'AGENT_ERROR'
    | 'AGGREGATION_TRIGGERED' | 'AGGREGATION_COMPLETE' | 'REWARD_DISTRIBUTION_START' | 'REWARD_DISTRIBUTION_COMPLETE'
    // Sync flow events
    | 'VERIFICATION_START' | 'KNOWLEDGE_FETCH_ATTEMPT' | 'KNOWLEDGE_FETCH_SUCCESS'
    | 'TIMELOCK_COMMIT_ATTEMPT' | 'TIMELOCK_COMMIT_SUCCESS' | 'TIMELOCK_COMMIT_FAILURE' | 'TIMELOCK_REVEAL_RECEIVED'
    | 'VERIFICATION_COMPLETE' | 'REASONING_STEP' | 'VERIFICATION_ERROR'
    | 'GENERATOR_MOCK_USED';


// Recall Log Entry Data (For detailed tracing if implemented)
export interface RecallLogEntryData {
    timestamp: string; // ISO 8601
    type: RecallEventType;
    details: Record<string, any>; // Flexible details object
    requestContext?: string;
    agentId?: Address | string; // Allow Address type
    correlationId?: string;
    durationMs?: number;
    errorDetails?: string;
}

// --- API Responses ---
export interface ApiAskResponse {
    message: string;
    requestContext: string;
    recallKey: string; // Key where QuestionData is stored
}
export interface ApiVerifyResponse { // For Sync /verify flow
    answer: string;
    status: VerificationStatus;
    confidence?: number;
    usedFragmentCids?: string[];
    timelockRequestId?: string;
    timelockTxExplorerUrl?: string;
    statusCheckUrl?: string;
    recallTrace?: RecallLogEntryData[];
    recallExplorerUrl?: string;
    error?: string;
    details?: string;
    requestContext?: string;
}

// Declaration for formatGwei helper used in recallService logging if needed
// declare function formatGwei(value: bigint): string;

// ==== End ./src/types/index.ts ====